<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xilinx-HLS on Ramon Heras</title>
    <link>https://ramonheras.com/tags/xilinx-hls/</link>
    <description>Recent content in Xilinx-HLS on Ramon Heras</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ramonheras.com/tags/xilinx-hls/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Enabling Burst Transactions on an AXIM Interface in HLS</title>
      <link>https://ramonheras.com/posts/axim-2/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ramonheras.com/posts/axim-2/</guid>
      <description>Burst transactions are essential to take full advantage of the AXIM interface. After performing many tests and reading the documentation several times, I must say that there is not a well-defined behavior of Vitis HLS. In this post, I summarize my thoughts and experimentation results on optimizing burst transactions. You can find an introductory blog to this topic here.
Unfortunately, the only way to ensure bursting is by diving into the wave viewer to check for it yourself.</description>
      <content>&lt;p&gt;Burst transactions are essential to take full advantage of the AXIM interface. After performing many tests and reading the documentation several times, I must say that there is not a well-defined behavior of Vitis HLS. In this post, I summarize my thoughts and experimentation results on optimizing burst transactions. You can find an introductory blog to this topic here.&lt;/p&gt;
&lt;p&gt;Unfortunately, the only way to ensure bursting is by diving into the wave viewer to check for it yourself. In Vitis 2020.2, there is a section specifically to report burst-related issues, the *AXI_M Burst Information&amp;rdquo; section located in the &amp;ldquo;Synthesis Summary.&amp;rdquo; In older versions, you can still find this information by skimming through the synthesis warnings or checking the synthesis log on the console. Unfortunately, this report is not accurate enough and tends to throw many false messages. Still, I follow the tool&amp;rsquo;s guidance, hoping that someday it&amp;rsquo;ll be more accurate or at least consistent with the documentation.&lt;/p&gt;
&lt;h2 id=&#34;access-pattern&#34;&gt;Access Pattern&lt;/h2&gt;
&lt;p&gt;The access pattern is the most critical aspect to make the burst optimization succeed. The access pattern must be sequential and incremental. The simplest way to ensure such an access pattern is by using an array as a top function parameter that is accessed from a single loop (to avoid overlapping).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ARRAY_SIZE; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
    outputArray[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inputArray[i]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;val;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;top-parameter-alignment&#34;&gt;Top Parameter Alignment&lt;/h2&gt;
&lt;p&gt;When you tell HLS to use a particular interface (AXIM or AXI Lite), HLS just adds an IP core called an adapter that defines the bus functional model and takes care of all the interfacing logic (See pages 233-236). The alignment of the parameter that you put on the top function concerns the interfacing between the HLS core and the adapter. Types aligned to a smaller value than the interface width lead to a bottleneck. This is because the AXIM adapter is capable of reading up to 4 bytes per clock cycle (for a 32-bit wide interface), but the HLS core only reads from the adapter the number of bytes to which the top parameter is aligned, per clock cycle. For instance, if the top parameter is a char, access is limited to only a single byte per clock.&lt;/p&gt;
&lt;h2 id=&#34;quick-note-on-structs&#34;&gt;Quick Note on Structs&lt;/h2&gt;
&lt;p&gt;As previously mentioned, when using structs, be careful with alignment since it limits the access in HLS. In the example below, the struct alignment is 1 byte, which limits access to a single byte of data per clock cycle. You might be tempted to use pragmas to solve this issue, perhaps partitioning the inner array  or aggregating the struct, but none of those solutions will work. Partitioning the inner array will not work because the only place to put this pragma is in the struct constructor, and since it is an interface, the pragmas inside of it are ignored. And aggregating the struct will not work neither because using the aggregate pragma on an AXI master interface is not allowed . In contrast, if you were after an AXI stream interface, the aggregation would be automatic. The correct solution is much simpler. Simply align the struct properly using the C++ keyword alignas to read the struct entirely in a single clock cycle.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//Default alignment 1 byte
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Sample_t&lt;/span&gt;{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; data[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;];
};

&lt;span style=&#34;color:#75715e&#34;&gt;//Proper alignment 4 bytes
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alignas&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;) Sample_t{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; data[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;memcpy&#34;&gt;Memcpy?&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleCore2b&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; inputArray[ARRAY_SIZE], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; outputArray[ARRAY_SIZE], ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; val){
&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface s_axilite port=return bundle=CONTROL
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface s_axilite port=val bundle=CONTROL
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface m_axi port=inputArray offset=slave bundle=GMEM0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface m_axi port=outputArray offset=slave bundle=GMEM0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; localBuffer[ARRAY_SIZE];
memcpy(localBuffer, (&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)inputArray, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ARRAY_SIZE);


&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ARRAY_SIZE; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
    outputArray[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; localBuffer[i]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;val;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In many examples, a local buffer is used along with memcpy to copy the data from the parameter (the interface) to the local buffer; see the code above. This approach is necessary when the burst optimization is not being applied. Sometimes, HLS cannot guess burst length due to a bad access pattern or other reasons. Using a local buffer effectively forces burst transactions, though this strategy has two main drawbacks. First, additional memory resources are needed to allocate the local buffer [either SLICEMs (to create distributed RAM), BRAMs, or URAMs]. Second, the burst length is of a fixed size, filling the entire buffer regardless of whether the entire buffer is needed.&lt;/p&gt;
&lt;h2 id=&#34;volatile&#34;&gt;Volatile?&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; fooA(&lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; inputArray[ARRAY_SIZE])
    &lt;span style=&#34;color:#75715e&#34;&gt;// Or
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; fooB(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; inputArray[ARRAY_SIZE])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Xilinx documentation is not very clear about whether or not to use the volatile qualifier on the top parameter. On pages 159 and 160, they state that volatile, following the standard C/C++ behavior, instructs the HLS tool not to optimize the variable to which it is applied. This may include no burst access, port widening, or dead code elimination.&lt;/p&gt;
&lt;p&gt;But then, on pages &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=169&#34;&gt;169-171&lt;/a&gt; and &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=228&#34;&gt;228-238&lt;/a&gt;, Xilinx provides many examples using the volatile and explains that volatile is used on ports (top function parameters) that are read from or written to several times during the code execution, especially on pointers. This same section refers to &amp;ldquo;Optimizing Burst Transfers&amp;rdquo; (&lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=315&#34;&gt;page 315&lt;/a&gt;), where there is yet another example without the volatile keyword. Furthermore, using volatile throws the burst failure 5, &lt;a href=&#34;https://www.xilinx.com/html_docs/xilinx2020_2/hls-guidance/214-227.html&#34;&gt;error [214-227]&lt;/a&gt;. One more caveat is that you cannot use an arbitrary precision (AP) type (such as ap_int or ap_fixed) along with the volatile qualifier since AP types do not support the volatile qualifier (and the code would not compile), see &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=160&#34;&gt;page 160&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Well, that is the theory; in practice, using volatile does not prevent bursting every time. Generally, the impact on resource utilization is limited, but it can have a considerable effect on everything from resources to performance depending on the case. The only way to make sure that everything is working properly is by checking the wave window. I personally tend to follow the tool guidance and generally would not use the volatile qualifier in this scenario. Another caution that I take is not reading/writing the same element several times but instead, copying it to/from another variable before. That is not strictly necessary, but it is good practice, especially when writing/reading to variables instead of arrays. The code snippets below reflect what I&amp;rsquo;ve seen during code reviews.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Avoid writing to an output twice 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;out[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(something())
    out[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; var; &lt;span style=&#34;color:#75715e&#34;&gt;//second write
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(something()) out[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; var; &lt;span style=&#34;color:#75715e&#34;&gt;//Writing once
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;            out[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;; 


&lt;span style=&#34;color:#75715e&#34;&gt;// Avoid reading from an input twice 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(something(in[i])) var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; in[i]; &lt;span style=&#34;color:#75715e&#34;&gt;//Second read
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;                 var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; in[i]; &lt;span style=&#34;color:#75715e&#34;&gt;//Reading once
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(something(aux))  var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;                var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;just-checked-the-wave-viewer-and-the-burst-length-is-not-fully-optimal&#34;&gt;Just Checked the Wave Viewer, and the Burst Length Is Not Fully Optimal&amp;hellip;&lt;/h2&gt;
&lt;p&gt;After making sure that the access pattern is perfect or even using memcpy to force it, you might find that the burst length is shorter than the optimal length. For instance, a for loop might be split into several bursts. This scenario is quite common because  Vitis HLS limits the maximum burst length by default to just 16 beats. To change this, increment the burst read/write size to the desired value (256 is the maximum for a 32-bit wide interface). You can do this in either of the following ways.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Add the options max_read_burst_length=256 or max_write_burst_length=256 to the interface pragma&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Modify the default settings at &lt;code&gt;solution settings&lt;/code&gt; &amp;gt; &lt;code&gt;general / configuration settings&lt;/code&gt; &amp;gt; &lt;code&gt;config interface&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When setting up this value, there are two limitations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The AW_LEN signal, which specifies the burst length (number of beats per transaction), is only 8 bits wide; therefore, the maximum value is 255. In AXI, the minimum length is one beat, so the transaction length is the AW_LENGTH value plus one. This way, a value of AW_LENGTH of 0 signifies a single beat transaction (the minimum). Therefore, the maximum burst size is really 256.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The limit for a burst is 4 KB per transaction; this is an AXI standard limitation. Therefore the maximum burst size depends on the channel TDATA width as well.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following formula agglutinates the two limitations described above:&lt;/p&gt;
&lt;p&gt;$$
maxReadBurstLength = min(4096/axiChannelByteWidth,\ 256)
$$&lt;/p&gt;
&lt;h2 id=&#34;optimizing-a-bit-more&#34;&gt;Optimizing A Bit More&lt;/h2&gt;
&lt;p&gt;By adding the latency option to the interface pragma, you can specify the expected latency. That might be a little confusing at first glance since there are two latencies involved with an AXIM burst.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Read latency: the number of clock cycles between requesting a read and receiving the first datum&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write latency: the amount of time between the first write request and receiving the write acknowledgment&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Specifying this latency option allows your IP to request access to the channel before it is needed. The best way to optimize your system is by monitoring all the transactions and synchronizing the different modules to share the memory bandwidth efficiently, rather than playing with the latency option alone. Note that if you choose a value too high, the IP core might have access to the channel before actually needing it, therefore not using it and wasting bandwidth.&lt;/p&gt;
&lt;p&gt;Similarly, if the latency value is too low, your core might stall waiting for access. As a good starting point, I would leave the default value as is. On &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=311&#34;&gt;page 311&lt;/a&gt;, there is a more detailed explanation of the implied latencies.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface m_axi port=outputArray offset=slave bundle=GMEM0 latency=&amp;lt;value&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;last-notes-when-using-axim-powered-ip-cores&#34;&gt;Last Notes When Using AXIM Powered IP Cores&lt;/h2&gt;
&lt;p&gt;In addition to the practices discussed in the previous section, another precaution must be taken when inferring burst transactions. A read or write burst must not cross the 4 KB boundaries; this rule is an AXI standard limitation. To verify this, the following statement must be true:&lt;/p&gt;
&lt;p&gt;$$
\displaylines{(StartingAddr\ \%\ 4096)+BurstLength*BurstSize&amp;lt;4K=4096\\&lt;br&gt;
BurstLength→Number\ of\ transfers/beats\\&lt;br&gt;
BurstSize→Number\ of\ bytes\ per\ transfer/beat}
$$&lt;/p&gt;
&lt;p&gt;For the first example (100 beats of 4 bytes) and given an starting address of 0x7871D0, the statement is as follows:&lt;/p&gt;
&lt;p&gt;$$
\displaylines{(7893456\ \%\ 4096)+100*4&amp;lt;4K=4096\rightarrow 464+400&amp;lt;4K\rightarrow864&amp;lt;4096 \rightarrow OK!}
$$&lt;/p&gt;
&lt;p&gt;The easiest way to avoid manually checking the above all the time is to use buffers already aligned to 4 KB; this method gives you the benefit of pushing the burst size to the 4 KB limit. See the examples below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Instead of This
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; buff[N];

&lt;span style=&#34;color:#75715e&#34;&gt;// This (C++11)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;alignas&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p[N];

&lt;span style=&#34;color:#75715e&#34;&gt;// This (C11 User space)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; buff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)aligned_alloc(&lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;N);

&lt;span style=&#34;color:#75715e&#34;&gt;// This (C Kernel space)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;linux/slab.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kmem_cache_t&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;buff_cache &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (kmem_cache_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)kmem_cache_create(
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;buff_4k_cache&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;N,
        &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;/* 4K alignment */&lt;/span&gt;
        SLAB_HWCACHE_ALIGN); &lt;span style=&#34;color:#75715e&#34;&gt;// Add | SLAB_POISON | SLAB_RED_ZONE for debugging
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>The AXI Master interface in HLS (The Basics)</title>
      <link>https://ramonheras.com/posts/axim-1/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ramonheras.com/posts/axim-1/</guid>
      <description>The AXI4 master is a powerfull interface that supports many features, but probably the most remarkable feature is support for burst transactions (Covered in detail in this post). An AXI Master (AXIM) interface is commonly used to access the DDR memory, though it can also be used to access other cores, such as BRAM or URAM. On the other side, an AXIM is complex and requires a lot of FPGA real estate.</description>
      <content>&lt;p&gt;The AXI4 master is a powerfull interface that supports many features, but probably the most remarkable feature is support for burst transactions (Covered in detail in this post). An AXI Master (AXIM) interface is commonly used to access the DDR memory, though it can also be used to access other cores, such as BRAM or URAM. On the other side, an AXIM is complex and requires a lot of FPGA real estate. The operating frequency is also significantly reduced in comparison to different interfaces, such as the AXI stream.&lt;/p&gt;
&lt;p&gt;This post addresses the basics of designing an AXIM-powered IP core. It is written with the assumption that the reader has some knowledge regarding this interface. If you do not, I recommend watching &lt;a href=&#34;https://www.youtube.com/watch?v=1zw1HBsjDH8&amp;amp;list=PLaSdxhHqai2_7WZIhCszu5PLSbZURmibN&#34;&gt;these videos&lt;/a&gt; or reviewing the &lt;a href=&#34;https://developer.arm.com/documentation/ihi0022/e/AMBA-AXI3-and-AXI4-Protocol-Specification&#34;&gt;AMBA AXI specification documentation&lt;/a&gt;. Throughout this post, I will be referring to the HLS documentation quite often, in particular to &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf&#34;&gt;UG1399-v2020.2&lt;/a&gt;. As I explain later on, some concepts in the documentation are not clear enough, in my opinion.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with some code. The code below is the simplest example using AXIM that I can think of. It takes an input array and adds the value of val to each element. Both val and the starting address from which the AXI master interface will read the array are set through an AXI-Lite slave interface.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SimpleCore&lt;/span&gt;( &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; inputArray[ARRAY_SIZE], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; outputArray[ARRAY_SIZE], ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; val){
	&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface s_axilite port=return bundle=CONTROL
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface s_axilite port=val bundle=CONTROL
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface m_axi port=inputArray offset=slave bundle=GMEM0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface m_axi port=outputArray offset=slave bundle=GMEM0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ARRAY_SIZE; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
		outputArray[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inputArray[i]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;val;
 };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;offsetslave&#34;&gt;Offset=slave?&lt;/h2&gt;
&lt;p&gt;The AXIM is a master interface, so it is responsible for reading the data. The starting address from which to start reading is known as the slave address or offset. With the offset parameter, we specify how to tell our IP core the address. I have set it to slave, which causes the HLS tool to create a slave register to set the slave address. This register can either be read or written by your system&amp;rsquo;s processor through an AXI-Lite slave interface that is also added to your IP core.&lt;/p&gt;
&lt;p&gt;There are other modes for this setting, such as &amp;ldquo;fixed&amp;rdquo; or &amp;ldquo;off,&amp;rdquo; but these modes are rarely used. The &amp;ldquo;direct&amp;rdquo; mode tells the HLS tool to add an extra input to the core instead of using an AXI Lite register. Finally, the &amp;ldquo;off&amp;rdquo; option does not create any offset port nor an AXI-Lite register. In this last case, the starting address is configured in the IP Integrator window (&amp;ldquo;Base address of target slave,&amp;rdquo; &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=241&#34;&gt;page 241&lt;/a&gt;) when instantiating the core in the block design in Vivado. Note that this last approach does not allow you to change the address at runtime.&lt;/p&gt;
&lt;h2 id=&#34;int-or-intsize&#34;&gt;&lt;code&gt;int*&lt;/code&gt; or &lt;code&gt;int[SIZE]&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;In C/C++, there is no difference between both options. However, I prefer the second option because it tells HLS the burst depth so that I do not have to specify it manually with the pragma option depth, this way you keep the pragma line cleaner. The tool might indicate that the depth is still 0 but the simulation is not going to fail, as it would do if you were not specified the size anywhere.&lt;/p&gt;
&lt;p&gt;The depth parameter indicates the maximum burst length and is used in co-simulation. HLS uses the depth parameter to calculate the size of the FIFO that interfaces the C++ test bench with the RTL core under test. A FIFO is necessary for each streaming interface, including AXIM and AXI-Stream. If the depth parameter is not specified, the cosim is likely to fail since HLS usually cannot deduce the burst length from the code.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt; &lt;span style=&#34;color:#75715e&#34;&gt;#pragma HLS interface m_axi port=outputArray depth=100 offset=slave bundle=GMEM0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;top-parameter&#34;&gt;Top Parameter&lt;/h2&gt;
&lt;p&gt;The top function parameter will most likely be an array or pointer (which, in practice, are the same), but of what type? As with other interfaces, you can either use (1) a C/C++ type (int, char, etc.…), (2) an arbitrary type (ap_int, ap_uint. Check out the post &amp;ldquo;Why use arbitrary types&amp;rdquo;) or (3) a custom struct. Simplicity is best, especially with an AXI Master interface, so I tend to use an int32 because it is of the same size as the interface, 32 bits. Sometimes a struct might be more suitable, but it can be tricky due to alignment concerns—learn more about alignment in the Enabling Burst Transactions post.&lt;/p&gt;
&lt;h2 id=&#34;last-notes-when-using-axim-powered-ip-cores&#34;&gt;Last Notes When Using AXIM Powered IP Cores&lt;/h2&gt;
&lt;p&gt;One important precaution must be taken when setting the slave address. Make sure that this address is aligned with the interface width (normally 4 bytes). To check this, you must make sure that the starting address value modulo the interface byte width is 0 . Or, since the interface width is limited to a power of two by the standard, the first least significant bits must be 0.&lt;/p&gt;
&lt;p&gt;$$
\displaylines{StartingAddr \% AximTdataByteWidth== 0 == StartingAddr[(AximDataByteWidth-1):0 ]\\&lt;br&gt;
[a:b]→range\ of\ bits\ from\ \mathbf{a}\ to\ \mathbf{b}\ boundaries\ included.\ Ej\ [2:0]→[b_2,b_1,b_0]}
$$&lt;/p&gt;
&lt;p&gt;When dealing with burst transactions, there is another critical aspect to remember regarding burst lengths. Learn more about this issue by reading the article &lt;strong&gt;Enabling Burst Transactions&lt;/strong&gt;.&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Why use HLS data types</title>
      <link>https://ramonheras.com/posts/hls-types/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ramonheras.com/posts/hls-types/</guid>
      <description>The C/C++ language has many data types that most people are familiar with, from the basic ones, char, int, unsigned, and float, to the bit accurate std types, including int8_t, int32_t, and more. If there are so many data types to choose from, why would we even bother with new ones? What are the advantages of HLS types? How can these data types be used effectively? These questions will be answered in this post.</description>
      <content>&lt;p&gt;The C/C++ language has many data types that most people are familiar with, from the basic ones, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned&lt;/code&gt;, and &lt;code&gt;float&lt;/code&gt;, to the bit accurate std types, including &lt;code&gt;int8_t&lt;/code&gt;, &lt;code&gt;int32_t&lt;/code&gt;, and more. If there are so many data types to choose from, why would we even bother with new ones? What are the advantages of HLS types? How can these data types be used effectively? These questions will be answered in this post.&lt;/p&gt;
&lt;h1 id=&#34;types&#34;&gt;Types&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;arbitrary-bit-width-integer&#34;&gt;Arbitrary Bit Width Integer&lt;/h2&gt;
&lt;p&gt;The Xilinx arbitrary library provides two arbitrary types: &lt;code&gt;ap_int&lt;/code&gt; for signed integers, and &lt;code&gt;ap_uint&lt;/code&gt; for unsigned integers. The major advantage of HLS types over standard data types is that it generates more efficient and accurate hardware, as Xilinx states. Another advantage of HLS types over other data types is the ability to create integers of any width. But, keep in mind that the wider (more bits) the data type is, the more complex it is to operate, store, and route.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;ap_int.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; G_MAX_IMAGE_WIDTH  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; G_MAX_IMAGE_HEIGHT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;//BITS is the number of bits to store n
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; T BITS(T n){ &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; BITS(n&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); }

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; ui32 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ap_uint&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//Better than unsigned int or int32_t
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;   boolean &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
    ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  simple &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;;
    ap_uint&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; wide(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;123456789123456789123456789&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// big number (it does not fit in a int64)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    ap_uint&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  weight &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// small bit-wide types are commonly used, among others, in AI quantized models.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;   byte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFF&lt;/span&gt;;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
        ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;BITS(G_IMAGE_WIDTH)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;  width;
        ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;BITS(G_IMAGE_HEIGHT)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; height;
    } ImgSize;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Another great feature offered by the Xilinx library is the way in which &lt;code&gt;ap_int&lt;/code&gt; and &lt;code&gt;ap_uint&lt;/code&gt; treats return types for operations. When operating standard types, the return type is the same as the operands, leading to overflows (either positive or negative). For example, the addition of two chars of value 200 also returns a &lt;code&gt;char&lt;/code&gt;, but such a type cannot store the result since the upper limit for a &lt;code&gt;char&lt;/code&gt; is 255. On the other hand, HLS data types avoid losing information. The result of an operation will be of a type capable of storing any possible result, no matter the values of the operands. For instance, the addition of two &lt;code&gt;ap_int&amp;lt;8&amp;gt;&lt;/code&gt; is an &lt;code&gt;ap_int&amp;lt;9&amp;gt;&lt;/code&gt;  that cannot overflow, no matter the values of the operads. In the same manner, the multiplication results in an &lt;code&gt;ap_int&amp;lt;16&amp;gt;&lt;/code&gt;. Mixing signed and unsigned types will return a signed type, e.g., &lt;code&gt;ap_int&amp;lt;8&amp;gt;&lt;/code&gt; plus &lt;code&gt;ap_uint&amp;lt;8&amp;gt;&lt;/code&gt; is an &lt;code&gt;ap_int&amp;lt;10&amp;gt;&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;ap_int.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;hws_utils.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; i8;
    ap_uint&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; u8;

    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; TypeInfo&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(u8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; u8) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        &lt;span style=&#34;color:#75715e&#34;&gt;// ap_uint&amp;lt;9&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; TypeInfo&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(u8 &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; u8) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        &lt;span style=&#34;color:#75715e&#34;&gt;// ap_uint&amp;lt;16&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; TypeInfo&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(u8 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i8) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; &lt;span style=&#34;color:#75715e&#34;&gt;// u8 to integer is i9, i9+i8 = i10
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// ap_uint&amp;lt;10&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;C&amp;#43;&amp;#43;&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Auxiliary code from hws utils&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-C&amp;#43;&amp;#43;&#34; &gt;&lt;code&gt;
template&amp;lt;typename T&amp;gt;
struct TypeInfo;

template&amp;lt;int W&amp;gt;
struct TypeInfo&amp;lt;ap_int&amp;lt;W&amp;gt;&amp;gt;{
    static std::string Name(){
        std::stringstream  os;
        os &amp;lt;&amp;lt; &amp;#34;ap_int&amp;lt;&amp;#34; &amp;lt;&amp;lt; W &amp;lt;&amp;lt; &amp;#34;&amp;gt;&amp;#34;;
        return os.str();
    }
};
template&amp;lt;int W&amp;gt;
struct TypeInfo&amp;lt;ap_uint&amp;lt;W&amp;gt;&amp;gt;{
    static std::string Name(){
        std::stringstream  os;
        os &amp;lt;&amp;lt; &amp;#34;ap_uint&amp;lt;&amp;#34; &amp;lt;&amp;lt; W &amp;lt;&amp;lt; &amp;#34;&amp;gt;&amp;#34;;
        return os.str();
    }
};
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;h2 id=&#34;fixed-bit-width-type&#34;&gt;Fixed Bit Width Type&lt;/h2&gt;
&lt;p&gt;Fixed point arithmetics are essential in hardware development. This is a much simpler alternative to floating-point arithmetics while being more versatile than integers, though C/C++ does not contain types supporting fixed-point arithmetics. Implementing floating-point arithmetics requires complex logic, even with DSP (in Xilinx devices, the DSP48). However, the new Xilinx Versal lineup includes a more versatile DSP, the DSP58e, that is capable of operating floating-point data.&lt;/p&gt;
&lt;p&gt;The Xilinx arbitrary point library allows developers to use fixed-point data, but the utility of this library does not stop here. The library also includes many other features to craft the behavior of fixed-point data types. When declaring an &lt;code&gt;ap_fixed&lt;/code&gt; or &lt;code&gt;ap_ufixed&lt;/code&gt; (the latter for unsigned fixed-point values), it is possible to choose among different overflow and rounding (quantization, as Xilinx refers to it) modes.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ap_fixed&lt;/code&gt; comes in the shape of a template type, in which the first two template arguments are the total bit width (W), and the integer width (I).  The former is the number of bits occupied by the type, and the latter is the number of bits used to represent the integer part (See figure 1). The following two arguments are also mandatory and serve to specify the overflow (O) and rounding (Q) modes (see Table 1). Xilinx states that &lt;code&gt;AP_SAT&lt;/code&gt; requires extra hardware that can increase LUT utilization up to 20%. When resource utilization is not a concern, my personal preferences are &lt;code&gt;AP_SAT&lt;/code&gt; (saturation) and &lt;code&gt;SC_RND_CONV&lt;/code&gt; (convergent rounding). Otherwise, the default (&lt;code&gt;AP_WRAP&lt;/code&gt; and &lt;code&gt;SC_TRUNC&lt;/code&gt;) modes will work just fine. The last argument is optional and only makes sense when used alongside the &lt;code&gt;AP_WRAP&lt;/code&gt; mode. I do not find this argument particularly useful, so I leave it set to the default value (0) or a value equal to the integer width (I). If you are unfamiliar with these overflow and rounding methods, there are examples of each method in UG1399 pages 516 to 519.&lt;/p&gt;
&lt;p&gt;
  &lt;figure class=&#34;center&#34; &gt;
    &lt;img src=&#34;https://ramonheras.com/images/HLS-Types/integer.jpg&#34;  alt=&#34;Fixed-Point Data Type Bits&#34;   /&gt;
    
  &lt;/figure&gt;


&lt;strong&gt;Figure 1&lt;/strong&gt; Fixed-Point Data Type Bits&lt;/p&gt;
&lt;p&gt;
  &lt;figure class=&#34;center&#34; &gt;
    &lt;img src=&#34;https://ramonheras.com/images/HLS-Types/table1.jpg&#34;  alt=&#34;Fixed-Point Identifier Summary&#34;   /&gt;
    
  &lt;/figure&gt;


&lt;strong&gt;Table 1&lt;/strong&gt; Fixed-Point Identifier Summary &lt;a href=&#34;https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1399-vitis-hls.pdf#page=495&#34;&gt;[UG1399-Xil2020]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In Table 1, the second column (&lt;code&gt;ap_fixed&lt;/code&gt; Types) lists the option aliases for C/C++, while the first column (System C Types) is for System C. Let&amp;rsquo;s see some examples.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;ap_fixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, AP_RND_CONV, AP_SAT&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; integer;
ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, AP_RND, AP_WRAP&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ufixed;

ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, AP_RND, AP_SAT&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;    fx10;
ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, AP_RND, AP_WRAP, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; fx5;
ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, AP_RND, AP_WRAP, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; fx8;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Another great feature is that the resulting &lt;code&gt;ap_fixed&lt;/code&gt; of mixing types in a mathematical expression can losslessly contain any possible result, as it happens with &lt;code&gt;ap_int&lt;/code&gt;. This occurs in the same way as with &lt;code&gt;ap_int&lt;/code&gt;. First, mixing signed and unsigned types will result in a signed type. Second, the resulting type total and integer width parameters will be large enough to store any result.&lt;/p&gt;
&lt;p&gt;However, there is a warning regarding the rounding and overflow parameters, which are set to the default values independently of the operands. This occurs even when mixed types only differ in bit widths (see the second example below).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; TypeInfo&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(fx10) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;Name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#75715e&#34;&gt;// ap_ufixed&amp;lt;10, 5, SC_RND, SC_SAT&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; TypeInfo&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(fx10 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fx10) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;Name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; 
    &lt;span style=&#34;color:#75715e&#34;&gt;// ap_ufixed&amp;lt;11, 5, SC_TRN, SC_WRAP&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; TypeInfo&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(fx10 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; u8) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;Name() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#75715e&#34;&gt;// ap_ufixed&amp;lt;9, 9, SC_TRN, SC_WRAP&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, it is worth mentioning that mixing fixed and integer types is possible! That is because an integer can be represented by an &lt;code&gt;ap_fixed&lt;/code&gt; with equal total and integer widths.&lt;/p&gt;
&lt;h1 id=&#34;tricks&#34;&gt;Tricks&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&#34;accessing-a-specific-bit&#34;&gt;Accessing a Specific Bit&lt;/h2&gt;
&lt;p&gt;Accessing a specific bit is quite simple using the operator [], which returns a reference to the specified bit. Accessing a specific bit is quite simple using the operator [], which returns a reference to the specified bit. Since the operator returns a reference, we can either read or write to the specified bit.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;// On the left side
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;pp[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//MSB
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;pp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//LSB
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// On the right side
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(pp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;accessing-ranges-of-bits&#34;&gt;Accessing Ranges of Bits&lt;/h2&gt;
&lt;p&gt;Ranges of bits can be accessed using the method &lt;code&gt;range(Hi, Low)&lt;/code&gt;, or in a more straightforward manner, the operator &lt;code&gt;(Hi, Low)&lt;/code&gt;, which takes the subvector [Hi:Low] with boundaries included. For example, &lt;code&gt;num.range(9, 5)&lt;/code&gt; or &lt;code&gt;num(9, 5)&lt;/code&gt; is a vector with references to bits 3, 2, and 1 from MSB to LSB.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, AP_RND, AP_WRAP&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; integerPart    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, AP_RND, AP_WRAP&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; fractionalPart &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;.25&lt;/span&gt;;
ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, AP_RND, AP_WRAP&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; num;

&lt;span style=&#34;color:#75715e&#34;&gt;// On the left side
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;num.range(&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; integerPart; &lt;span style=&#34;color:#75715e&#34;&gt;// Using &amp;#34;range&amp;#34; method
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;num(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fractionalPart;    &lt;span style=&#34;color:#75715e&#34;&gt;// Using operator ()
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// On the right side
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(num.range(&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; num &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;using-ap_fixed-to-enhance-integers&#34;&gt;Using ap_fixed to Enhance Integers&lt;/h2&gt;
&lt;p&gt;A helpful trick is using an &lt;code&gt;ap_fixed&lt;/code&gt; with equal data and integer widths instead of an &lt;code&gt;ap_int&lt;/code&gt; to create an integer. The &lt;code&gt;ap_fixed&lt;/code&gt; enables controlling the rounding and quantization modes; We don&amp;rsquo;t have such control with ap_int.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;W&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; iW;
ap_fixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;W, W, AP_RND_CONV, AP_SAT&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; iW2; &lt;span style=&#34;color:#75715e&#34;&gt;// Now we can change modes
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;converting-to-cc-types&#34;&gt;Converting to C/C++ Types&lt;/h2&gt;
&lt;p&gt;HLS types support implicit conversions for most types, but you can also explicitly convert these data types using the methods &lt;code&gt;to_&amp;lt;type&amp;gt;()&lt;/code&gt;; for example, &lt;code&gt;to_char&lt;/code&gt;, &lt;code&gt;to_int&lt;/code&gt;, &lt;code&gt;to_uint&lt;/code&gt;, &lt;code&gt;to_int64&lt;/code&gt;, &lt;code&gt;to_uint64&lt;/code&gt;, to &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;to_half&lt;/code&gt;. When converting data types, note that truncation is used instead of the selected rounding mode.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c1(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0b100000001&amp;#34;&lt;/span&gt;);
ap_ufixed&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, AP_RND, AP_WRAP&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; c2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7.75&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; cc1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c1.to_char()&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cc1 = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; cc1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#75715e&#34;&gt;// cc1 = 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; cc2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c2.to_int();
cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cc2 = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; cc2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#75715e&#34;&gt;// cc2 = 7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;console-printing&#34;&gt;Console Printing&lt;/h2&gt;
&lt;p&gt;Hardware development involves dealing with bit vectors, and representing this data in binary or hexadecimal formats is clearer than using the decimal format. Fortunately, the presented HLS types (&lt;code&gt;ap_int&lt;/code&gt; and &lt;code&gt;ap_fixed&lt;/code&gt;) can be printed as standard types. In addition, the iomanip library helps with formating the printed output, e.g. limiting the number of digits or choosing the adecuate base, among other features. Some of these capabilities are demonstrated in the example below.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
ap_int&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; aa &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;;

cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; aa &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; &lt;span style=&#34;color:#75715e&#34;&gt;// base 10 by default
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 255
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; setbase(&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; aa &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; &lt;span style=&#34;color:#75715e&#34;&gt;// Supports Hex, Oct, Dec but not Binary
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 0xFF
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; aa.to_string() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; &lt;span style=&#34;color:#75715e&#34;&gt;// though, you can use to_string( base ); base is 2 by default
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 0b11111111
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, aa.to_string(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;).c_str()); &lt;span style=&#34;color:#75715e&#34;&gt;// Or base 10
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 255
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
    <item>
      <title>Automate HLS IP Core Deployment</title>
      <link>https://ramonheras.com/posts/devops-2/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ramonheras.com/posts/devops-2/</guid>
      <description>In the last post, we introduced our new CI system and its remarkable features, such as automated testing and code coverage report generation. However, that was just the beginning step in our journey to automate most processes to save time and focus on what matters, providing better-quality code to our customers. In this second stage, we have automated the deployment process. In our case, this boils down to pushing repository changes to our customers&amp;rsquo; git server.</description>
      <content>&lt;p&gt;In the last post, we introduced our new CI system and its remarkable features, such as automated testing and code coverage report generation. However, that was just the beginning step in our journey to automate most processes to save time and focus on what matters, providing better-quality code to our customers. In this second stage, we have automated the deployment process. In our case, this boils down to pushing repository changes to our customers&amp;rsquo; git server.&lt;/p&gt;
&lt;p&gt;We understand that each organization uses unique processes that do not necessarily match ours; therefore, the main goal was to isolate our customers&amp;rsquo; processes from ours. To accomplish this task, we used two separated repos: one in our git server provider, and another hosted by our customer. In our repo, we keep track of all source code and configuration files. During the deployment, all the outputs are generated, from the IP core to the HTML reports and documents. Next, all these outputs are moved to a &amp;ldquo;clean repository.&amp;rdquo; Finally, the clean repository is pushed to the customer&amp;rsquo;s repository using a provided SSH key.&lt;/p&gt;
&lt;p&gt;The customer owns a repository in which there is no need to run any script to read reports and documentation or import the IP core to the Vivado IP catalog. Depending on the project (for most projects), we also include the source code. Most projects involve designing custom libraries; hence, it does not make sense to export the IP core alone. Instead, we include the underlying library used to build the IP core, and, if it is requested, all related code such as external included files and tests.&lt;/p&gt;
&lt;p&gt;
  &lt;figure class=&#34;center&#34; &gt;
    &lt;img src=&#34;https://ramonheras.com/images/DevOps-2/pipeline.jpg&#34;  alt=&#34;Deployment Pipeline&#34;   /&gt;
    
  &lt;/figure&gt;


&lt;strong&gt;Figure 1&lt;/strong&gt; Deployment Pipeline&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📝 &lt;em&gt;This post was initially released on the HLS Works Blog in 2020. The post was migrated to this web after the HLS Works closed in Sep 2021. The entire pipeline is planned to be open-sourced in the the near future.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
    <item>
      <title>Automate test execution HLS</title>
      <link>https://ramonheras.com/posts/devops-1/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ramonheras.com/posts/devops-1/</guid>
      <description>Nowadays, continuous integration (CI) is a must, and including CI in our workflow has been a game-changer. We have automated many processes to save an enormous amount of time that can be spent on improving quality and delivering a better product to our customers.
To fully integrate dev-ops into our processes, we have automated test execution and code coverage report generation. Tests in HLS differ significantly from typical software development. In software development, a typical CI workflow compiles and executes tests in several different environments with distinct operating systems and configurations.</description>
      <content>&lt;p&gt;Nowadays, continuous integration (CI) is a must, and including CI in our workflow has been a game-changer. We have automated many processes to save an enormous amount of time that can be spent on improving quality and delivering a better product to our customers.&lt;/p&gt;
&lt;p&gt;To fully integrate dev-ops into our processes, we have automated test execution and code coverage report generation. Tests in HLS differ significantly from typical software development. In software development, a typical CI workflow compiles and executes tests in several different environments with distinct operating systems and configurations. In HLS, executing the software is just the beginning of the pipeline C simulation (C SIM). A software CI workflow lacks synthesis, co-simulation, and IP exportation. Checking all of these can be tedious and time-consuming, but with the help of automation and CI tools, this process becomes much easier!&lt;/p&gt;
&lt;p&gt;There are many challenges to obtaining this workflow, from building in-house tools to hosting the entire CI system on our own servers. This is due to execution time constraints and the large amount of memory taken by Xilinx tools.
What Have We Automated?&lt;/p&gt;
&lt;p&gt;We execute a pipeline of operations on each commit to ensure that our code is not broken at any stage:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The server runs the tests as regular software (C Simulation or csim for short). We use this step to find early errors as soon as possible since this is the fastest part of the pipeline.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The server re-runs the tests but enabling code coverage. With code coverage, we check that each line of code has been executed. It does not ensure the quality of the tests, but it is an essential check.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, the server executes unit and integration tests running C synthesis, co-simulation, and IP exportation for each test.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the test pipeline completes successfully, the deployment pipeline is triggered.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Step 3 is the most time-consuming and complex. It can be split into three sub-processes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;C Synthesis is executed to verify synthesizability. Identifying non-synthesizable code as soon as possible is crucial to don&amp;rsquo;t waste time later. Next, synthesizable code is translated to RTL, leaving the remaining code as C/C++. The RTL code can be either VHDL or Verilog.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In co-simulation, C/C++ code runs as normal software, whereas the RTL hardware description is simulated. Vitis HLS inserts several interfaces to enable data transfers between the software part and the RTL simulation. This step is the slowest due to the RTL simulation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ip exportation does not simply package the core and the drivers. It also runs extra checking in Vivado to verify functionality, i.e., place and route, among other tests. Those tests culminate in a final report on resource utilization, throughput, max clock frequency, etc. This report is more accurate than the one generated by C Synthesis.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Detecting any breaks in the pipeline at commit granularity has saved our customers a lot of time and money. Figure 1 illustrates the described flow.
Figure 1 Test pipeline&lt;/p&gt;
&lt;p&gt;
  &lt;figure class=&#34;center&#34; &gt;
    &lt;img src=&#34;https://ramonheras.com/images/DevOps-1/pipeline.jpg&#34;  alt=&#34;Test pipeline&#34;   /&gt;
    
  &lt;/figure&gt;


&lt;strong&gt;Figure 1&lt;/strong&gt; Test pipeline&lt;/p&gt;
&lt;p&gt;Our automated system executes the pipeline described above (C simulation, synthesis, co-simulation, and IP exportation) in various Vitis HLS versions (2020.1 and 2020.2) and operating systems (Windows 10 and Ubuntu 20.04|18.4), running all tasks in parallel to improve execution times.&lt;/p&gt;
&lt;h2 id=&#34;this-is-only-the-beginning&#34;&gt;This Is Only the Beginning.&lt;/h2&gt;
&lt;p&gt;The HLS Works operations roadmap includes much more automation, specifically in the field of deployment operations. From documentation generation and deployment to code deployment, all these topics [KA1] will be covered in a later post.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;📝 &lt;em&gt;This post was initially released on the HLS Works Blog in 2020. The post was migrated to this web after the HLS Works closed in Sep 2021. The entire pipeline is planned to be open-sourced in the the near future.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
  </channel>
</rss>
